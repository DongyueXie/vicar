% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ruvb.R
\name{ruvb}
\alias{ruvb}
\title{Bayesian version of Removing Unwanted Variation.}
\usage{
ruvb(Y, X, ctl, k = NULL, fa_func = bfa_gs_linked, fa_args = list(),
  cov_of_interest = ncol(X), include_intercept = TRUE,
  return_mcmc = FALSE, prior_fun = NULL)
}
\arguments{
\item{Y}{A matrix of numerics. These are the response variables
where each column has its own variance. In a gene expression
study, the rows are the individuals and the columns are the
genes.}

\item{X}{A matrix of numerics. The covariates of interest.}

\item{ctl}{A vector of logicals of length \code{ncol(Y)}. If
position i is \code{TRUE} then position i is considered a
negative control.}

\item{k}{A non-negative integer.The number of unobserved
confounders. If not specified and the R package sva is
installed, then this function will estimate the number of
hidden confounders using the methods of Buja and Eyuboglu
(1992).}

\item{fa_func}{A function that takes as input matrices named
\code{Y21}, \code{Y31}, \code{Y32}, and \code{k} and returns a
list, one of whose elements is called \code{Y22_array}. See
\code{\link{bsvd}} for an example function.}

\item{fa_args}{A list of additional parameters to pass to
\code{fa_func}.}

\item{cov_of_interest}{A vector of positive integers. The column
numbers of the covariates in X whose coefficients you are
interested in. The rest are considered nuisance parameters and
are regressed out by OLS.}

\item{include_intercept}{A logical. If \code{TRUE}, then it will
check \code{X} to see if it has an intercept term. If not, then
it will add an intercept term. If \code{FALSE}, then \code{X}
will be unchanged.}

\item{return_mcmc}{A logical. Should we return the MCMC draws?}

\item{prior_fun}{A function. This should take as inpute a matrix
and output a positive numeric.}
}
\value{
A list with with some or all of the following elements.

    \code{means} The posterior means of the betas.

    \code{sd} The posterior standard deviations of the betas.

    \code{medians} The posterior medians of the betas

    \code{upper} The posterior 97.5th percentile of the betas.

    \code{lower} The posterior 2.5th percentile of the betas.

    \code{lfsr1} The empirical local false sign rate. This just
    counts the number of betas that are less than 0 before
    calculating lfsr.

    \code{lfsr2} The normal approximation for local false sign
    rate. This approximates the posterior of each beta by a normal,
    then uses this approximation to calculate lfsr.

    \code{t} The posterior means divided by the posterior standard
    deviations.

    \code{svalues1} The svalues from lfsr1.

    \code{svalues2} The svalues from lfsr2.

    \code{betahat_post} An array of the posterior samples of the
    betas. Only returned if \code{return_mcmc} is \code{TRUE}.

    \code{fa} The raw output from whatever factor analysis is
    used. Only returned if \code{return_mcmc} is \code{TRUE}.
}
\description{
Right now, this only allows you to use a uniform prior on the
beta's. I plan on the future to allow you to input a function
that's the prior.
}
\details{
I have three versions of Bayesian factor analyses that I
recommend. The first, \code{\link{bfa_gs}} is the Bayesian factor
analysis used in Gerard and Stephens (2016). The second is
\code{\link{bfa_gs_linked}}. This version links the variances
between the factors and observations. The last is
\code{bfa_wrapper}, which is just a wrapper for the R package
bfa. The main thing about this version is that they do not use a
hierarchical prior on the variances.
}
\author{
David Gerard
}
\seealso{
\code{\link{bfa_gs}}, \code{\link{bfl}}, and
    \code{bfa_wrapper} for implemented Bayesian factor analyeses.
}

